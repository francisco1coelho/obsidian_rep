[[State of art]]

### ==verificar que abordagem devo de seguir==
# **Foundations and Related Technologies — Stage 2: Semantic Mapping**

## **Stage Introduction**

The second stage of the **NL→Dash** pipeline, **Semantic Mapping**, is responsible for translating the interpreted user intent into a structured and **semantically consistent representation of metrics, dimensions, and filters**. After the Prompt/Intent stage identifies the intent (e.g., _create dashboard for queue performance_), Semantic Mapping ensures that the terminology used by the user is **aligned with the system’s internal data model**.

This process guarantees that terms such as “average wait time” or “AHT” are mapped to the correct internal **Key Performance Indicators (KPIs)**, calculation logic, and database fields. The outcome of this phase is a **semantically aligned JSON structure**, ensuring that every metric and dimension referenced by the user corresponds to an actual data entity within the analytics warehouse.

Semantic Mapping thus plays a critical role in **bridging natural language and data semantics**, reducing ambiguity and maintaining the consistency of dashboards generated through language-driven interaction. In practical terms, it acts as a **semantic layer** that formalizes and validates metric definitions, providing a shared vocabulary across the NL→Dash pipeline.

---

## **Technological Analysis**

Several technologies and frameworks implement similar principles of semantic consistency between business metrics and data models. This section analyzes the most relevant ones — **dbt**, **Cube.js**, and **LookML** — as well as the **custom semantic layer** designed for this project.

### **dbt (Data Build Tool)**

**Advantages:**

- Open-source and widely adopted in modern data stacks;
    
- Enables **centralized metric definitions** and **data documentation** directly in the warehouse;
    
- Ensures metric consistency across dashboards and analyses through SQL-based models;
    
- Integrates well with pipelines for transformation and data validation.
    

**Limitations:**

- Primarily focused on **data transformation**, not on real-time visualization or interactive APIs;
    
- Requires a pre-existing **SQL infrastructure** and data warehouse;
    
- Less suitable for **on-demand semantic querying** in real-time scenarios.
    

**Fit to the project:**  
While dbt provides robust semantic consistency and governance, its batch-oriented nature makes it less suited for **real-time NL→Dash generation**, where the mapping must occur dynamically in response to user prompts. However, it establishes a strong conceptual foundation for **metric lineage** and **definition versioning**, which can inspire the project’s semantic layer.

---

### **Cube.js**

**Advantages:**

- Offers a powerful **semantic API layer** that abstracts complex queries into reusable metrics and dimensions;
    
- Supports **real-time streaming** and caching mechanisms, ideal for analytics dashboards;
    
- Provides flexible APIs compatible with multiple visualization front-ends;
    
- Facilitates **role-based data access** and fine-grained metric control.
    

**Limitations:**

- More complex to scale due to its **Node.js-based backend** and caching dependencies;
    
- Requires careful configuration to maintain low latency under high load;
    
- Steeper learning curve for teams unfamiliar with its API-driven model.
    

**Fit to the project:**  
Cube.js aligns closely with the **real-time semantic layer requirements** of NL→Dash. Its semantic abstraction and ability to serve metrics via APIs make it a strong candidate for integration or conceptual reference, especially for **mapping natural language KPIs to structured metrics** dynamically.

---

### **LookML (Looker Modeling Language)**

**Advantages:**

- Mature and **enterprise-grade semantic modeling language** integrated into Looker (Google Cloud);
    
- Strong support for **metric standardization**, version control, and governance;
    
- Simplifies complex analytical logic through reusable metric definitions.
    

**Limitations:**

- Proprietary and **tightly coupled to Looker’s ecosystem**;
    
- Limited flexibility when used outside the Looker environment;
    
- Less suitable for open integration into custom pipelines or lightweight architectures.
    

**Fit to the project:**  
LookML demonstrates the power of a **declarative semantic layer**, where metrics and relationships are explicitly defined. However, its **vendor lock-in** and lack of open integration make it unsuitable for an open, backend-driven system like NL→Dash. Its conceptual model, however, provides valuable inspiration for structuring **metric catalogs** and ensuring **semantic reusability**.

---

### **Custom Semantic Layer (Project-Specific Approach)**

**Advantages:**

- Fully adaptable to the **Contact Center as a Service (CCaaS)** domain, aligning precisely with the project’s data and business logic;
    
- Lightweight and integrable into the backend architecture;
    
- Enables custom **rule-based mappings**, such as synonym detection and KPI disambiguation;
    
- Offers full control over **semantic validation**, **metric lineage**, and **feedback integration**.
    

**Limitations:**

- Requires manual design of the **semantic schema**, including metrics, hierarchies, and relationships;
    
- Increased initial development effort for defining rules, taxonomies, and mapping logic;
    
- Maintenance depends on continuous updates to the **KPI ontology** as business requirements evolve.
    

**Fit to the project:**  
A **custom semantic layer** represents the most suitable solution for the NL→Dash pipeline. It combines the transparency and flexibility of open-source approaches (as seen in dbt and Cube.js) with the domain-specific precision required for **real-time mapping of natural language to KPIs**. This component enables the system to generate **semantically aligned JSON configurations**, ensuring consistency across user prompts, dashboards, and underlying data.

---

## **Critical Synthesis**

The **Semantic Mapping** stage ensures that natural language inputs are accurately translated into meaningful, system-recognized metrics and dimensions. While existing tools such as **dbt**, **Cube.js**, and **LookML** provide solid frameworks for semantic consistency, they are either too heavy for real-time processing or limited by proprietary ecosystems.

For the NL→Dash project, a **custom semantic layer** offers the best balance between **adaptability**, **lightweight integration**, and **domain-specific accuracy**. By embedding semantic rules directly into the backend, the system achieves **“semantically aligned JSON”** structures that maintain coherence between user intent and data representation — a prerequisite for the subsequent **JSON Generation** and **Validation** stages.

This approach reinforces the project’s objective: to create an intelligent, real-time analytics system capable of transforming natural language prompts into complete, semantically consistent dashboards.